// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
// g++ thrift_test.cpp gen-cpp/test_types.cpp -lthrift  -std=c++14 -o test  -L/Users/ronghuang/work/3rd_lib/boost/lib -lboost_log_setup -lboost_log
//otool -L exefile
//install_name_tool -change @executable_path/libboost_something.dylib /opt/local/lib/libboost_something.dylib exefile
#include "gen-cpp/test_types.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/transport/TServerSocket.h>

#include "thrift/protocol/TBinaryProtocol.h"
#include "thrift/transport/TBufferTransports.h"
#include <boost/shared_ptr.hpp>

#include <folly/io/IOBufQueue.h>

#include <iostream>
#include <string>

#include <memory>
#include <sstream>

#include <boost/crc.hpp>
#include <boost/log/attributes.hpp>
#include <boost/log/common.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks.hpp>
#include <boost/log/sources/logger.hpp>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
//using apache::thrift::BinarySerializer;

using apache::thrift::protocol::TBinaryProtocol;
using apache::thrift::transport::TMemoryBuffer;

using boost::shared_ptr;
#include <boost/log/core.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks/text_file_backend.hpp>
#include <boost/log/sources/record_ostream.hpp>
#include <boost/log/sources/severity_logger.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/utility/setup/file.hpp>

namespace logging = boost::log;
namespace src = boost::log::sources;
namespace sinks = boost::log::sinks;
namespace keywords = boost::log::keywords;

#define MAX_NUM 200
#include <fstream>


using namespace std;

void init()
{
    logging::add_file_log
    (
        keywords::file_name = "test_sample_%N.log",                                        /*< file name pattern >*/
        keywords::rotation_size = 10 * 1024 * 1024,                                   /*< rotate files every 10 MiB... >*/
        keywords::time_based_rotation = sinks::file::rotation_at_time_point(0, 0, 0), /*< ...or at midnight >*/
        keywords::format = "[%TimeStamp%]: %Message%"                                 /*< log record format >*/
    );

    logging::core::get()->set_filter
    (
        logging::trivial::severity >= logging::trivial::info
    );
}

void startLog()
{
  init();
    logging::add_common_attributes();

    using namespace logging::trivial;
    src::severity_logger< severity_level > lg;

    BOOST_LOG_SEV(lg, trace) << "A trace severity message";
    BOOST_LOG_SEV(lg, debug) << "A debug severity message";
    BOOST_LOG_SEV(lg, info) << "An informational severity message";
    BOOST_LOG_SEV(lg, warning) << "A warning severity message";
    BOOST_LOG_SEV(lg, error) << "An error severity message";
    BOOST_LOG_SEV(lg, fatal) << "A fatal severity message";
}

void testThrift()
{
  User u;
  u.__set_name("ddd");
  u.__set_age(9);
  u.__set_vip(true);

  std::string thriftStr, jsonStr;
  std::stringstream ss;

  ss << u;
  std::string s = ss.str();
  std::cout << s << '\n';
  //  int time;

  //  //①序列化为thrift binary protocol
  //  boost::shared_ptr<TMemoryBuffer> buffer(new TMemoryBuffer());

  // TBinaryProtocol binaryProtcol(*buffer);

  //  u.write(&binaryProtcol );
  //      buffer->getBufferAsString();
  //     auto str = buffer->getBufferAsString();

  // Use TFramedTransport
  const auto memory_buffer =
      std::make_shared<apache::thrift::transport::TMemoryBuffer>();
  apache::thrift::transport::TFramedTransport framed_transport(memory_buffer);
  framed_transport.write(reinterpret_cast<const uint8_t *>(s.data()),
                         (uint32_t)s.length());
  framed_transport.flush();
  std::string msg_content_framed = memory_buffer->getBufferAsString();

  std::cout << "thrift反序列化" << u << "==-ms\n";

  const auto buff =
      std::make_shared<apache::thrift::transport::TMemoryBuffer>();
  // apache::thrift::transport::TFramedTransport ff(buff);
  // ff.write(reinterpret_cast<const uint8_t*>(u.data()));

  std::fstream myfile;
  myfile = std::fstream("file.binary", std::ios::out | std::ios::binary);
  myfile << u;
  myfile.close();

}


void testThrift2()
{
  User u;
  u.__set_name("ddd");
  u.__set_age(9);
  u.__set_vip(true);

  std::string thriftStr, jsonStr;
  std::stringstream ss;

  ss << u;
  std::string s = ss.str();
 
  
  // Use TFramedTransport
  const auto memory_buffer =
      std::make_shared<apache::thrift::transport::TMemoryBuffer>();
  apache::thrift::transport::TFramedTransport framed_transport(memory_buffer);
  framed_transport.write(reinterpret_cast<const uint8_t *>(s.data()),
                         (uint32_t)s.length());
  framed_transport.flush();
  std::string msg_content_framed = memory_buffer->getBufferAsString();

  std::cout << "thrift序列化2" << msg_content_framed<<  "==-ms\n";
  
  folly::IOBufQueue queue;
  //apache::thrift::BinarySerializer::serialize(u, &queue);

  auto trans = std::make_shared<apache::thrift::transport::TMemoryBuffer>();
  apache::thrift::protocol::TBinaryProtocol proto(trans);
  int i = proto.writeString(std::string("hello test"));//writeBinary
  std::cout << "wrote " << i << "to TMemoryBuffer" << std::endl;


  std::string msg;
  i = proto.readString(msg);
  std::cout << "read = " <<i << " & "<< msg << std::endl; 


  std::fstream myfile;
  myfile = std::fstream("file2.dat", std::ios::out | std::ios::binary);
  myfile << trans->getBufferAsString();
  myfile.close();

  
}



void writeTest()
{
  User u;
  u.__set_name("ddd");
  u.__set_age(9);
  u.__set_vip(true);

  std::string thriftStr, jsonStr;
  
  // Use TFramedTransport 
  
  folly::IOBufQueue queue;
  //apache::thrift::BinarySerializer::serialize(u, &queue);

  auto trans = std::make_shared<apache::thrift::transport::TMemoryBuffer>();
  apache::thrift::protocol::TBinaryProtocol proto(trans);
  int i =0;//= proto.writeString(std::string("hello test"));//writeBinary
  //std::cout << "wrote " << i << "to TMemoryBuffer" << std::endl;

  u.write(&proto);

  u.__set_name("uuu");
  u.__set_age(12);
  u.__set_vip(true);
  u.write(&proto);
  

  std::fstream myfile;
  myfile = std::fstream("file2.dat", std::ios::out | std::ios::binary);
  myfile << trans->getBufferAsString();
  myfile.close();

  
}



void readTest()
{
  User u;
  
  // Use TFramedTransport   

  auto trans = std::make_shared<apache::thrift::transport::TMemoryBuffer>();
  apache::thrift::protocol::TBinaryProtocol proto(trans);
  
 
  

  
  std:: ifstream myfile("file2.dat", std::ifstream::binary);
  //myfile = std::ifstream("file2.dat", std::ios::in | std::ios::binary);
  char buff[1024];
  myfile.read(buff, 1024);
  size_t extracted = myfile.gcount();
  
  myfile.close();

  trans->resetBuffer((uint8_t *)buff,1024);

  //int i = proto.readByte((int8_t*)buff);//writeBinary

  string msg;
 

  int n=0;
  while(n<extracted)
  {
    n+=u.read(&proto);
  std::cout<< "read:" << msg << u<< std::endl;
  }

//goku::thrift::MetricMetadataLogEntry entry;

  
}

int main(int argc, char **argv) {

  //startLog();
  //testThrift();
  writeTest();
  readTest();

  int port = 9090;

  // boost::log::sources::logger_mt logger_;

  
  // BOOST_LOG(logger_) << std::move(s);

  // //②反序列thrift binary data
  // thriftSerializeTest::thriftBinaryDeserialize(thriftStr, &time);
  // cout << "thrift反序列化" << MAX_NUM << "次时间为" << time << "ms\n";

  // //③jsoncpp序列化为json
  // thriftSerializeTest::jsonSerialize(sc, &jsonStr, &time);
  // cout << "jsoncpp序列化json" << MAX_NUM << "次时间为" << time << "ms\n";

  // //④jsoncpp反序列化json
  // thriftSerializeTest::jsonDeserialize(jsonStr, &time);

  return 0;
}